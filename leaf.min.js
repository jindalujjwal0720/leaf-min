var TokenType;!function(e){e[e.Number=0]="Number",e[e.Identifier=1]="Identifier",e[e.String=2]="String",e[e.Set=3]="Set",e[e.To=4]="To",e[e.Always=5]="Always",e[e.Change=6]="Change",e[e.And=7]="And",e[e.Or=8]="Or",e[e.Task=9]="Task",e[e.If=10]="If",e[e.Else=11]="Else",e[e.For=12]="For",e[e.From=13]="From",e[e.In=14]="In",e[e.By=15]="By",e[e.Then=16]="Then",e[e.BinaryOperator=17]="BinaryOperator",e[e.RelationalOperator=18]="RelationalOperator",e[e.Equals=19]="Equals",e[e.Comma=20]="Comma",e[e.DotDot=21]="DotDot",e[e.OpenParen=22]="OpenParen",e[e.CloseParen=23]="CloseParen",e[e.OpenBracket=24]="OpenBracket",e[e.CloseBracket=25]="CloseBracket",e[e.OpenBrace=26]="OpenBrace",e[e.CloseBrace=27]="CloseBrace",e[e.EOF=28]="EOF"}(TokenType||(TokenType={}));const KEYWORDS={set:TokenType.Set,to:TokenType.To,always:TokenType.Always,change:TokenType.Change,and:TokenType.And,or:TokenType.Or,task:TokenType.Task,if:TokenType.If,then:TokenType.Then,else:TokenType.Else,for:TokenType.For,from:TokenType.From,in:TokenType.In,by:TokenType.By},BINARY_OPERATORS={plus:TokenType.BinaryOperator,minus:TokenType.BinaryOperator,times:TokenType.BinaryOperator,divide:TokenType.BinaryOperator,modulo:TokenType.BinaryOperator};function token(e="",t){return{value:e,type:t}}function isalpha(e){return e.toUpperCase()!=e.toLowerCase()}function isskippable(e){return" "==e||"\t"==e||"\r"==e||"\n"==e}function isint(e){const t=e.charCodeAt(0),r=["0".charCodeAt(0),"9".charCodeAt(0)];return t>=r[0]&&t<=r[1]}function skipline(e){for(;e.length>0&&"\r"!=e[0]&&"\n"!=e[0];)e.shift();e.shift()}function tokenize(e){const t=new Array,r=e.split("");for(;r.length>0;)if("."==r[0]){if(r.shift(),"."!=r[0])throw"Invalid token: .";t.push(token("..",TokenType.DotDot)),r.shift()}else if(","==r[0])t.push(token(r.shift(),TokenType.Comma));else if("("==r[0])t.push(token(r.shift(),TokenType.OpenParen));else if(")"==r[0])t.push(token(r.shift(),TokenType.CloseParen));else if("["==r[0])t.push(token(r.shift(),TokenType.OpenBracket));else if("]"==r[0])t.push(token(r.shift(),TokenType.CloseBracket));else if("{"==r[0])t.push(token(r.shift(),TokenType.OpenBrace));else if("}"==r[0])t.push(token(r.shift(),TokenType.CloseBrace));else if("="==r[0]||"<"==r[0]||">"==r[0]||"!"==r[0]){const e=r.shift();r.length>1&&"="==r[0]?t.push(token(e+r.shift(),TokenType.RelationalOperator)):"="==e?t.push(token(e,TokenType.Equals)):"!"!=e?t.push(token(e,TokenType.RelationalOperator)):(console.error("Invalid token: ",e),Deno.exit(1))}else if("+"==r[0]||"-"==r[0]||"*"==r[0]||"/"==r[0]||"%"==r[0])t.push(token(r.shift(),TokenType.BinaryOperator));else if("#"==r[0])skipline(r);else if('"'==r[0]){r.shift();let e="";for(;r.length>0&&'"'!=r[0];)e+=r.shift();'"'!=r.shift()&&(console.error("Invalid string literal: ",e,' - Missing closing "'),Deno.exit(1)),t.push(token(e,TokenType.String))}else if(isint(r[0])){let e="",n=0;for(;r.length>0&&(isint(r[0])||"."==r[0]);)if(e+=r.shift(),"."==r[0]){if(r.length>1&&"."==r[1])break;n++}n>1&&(console.error("Invalid number literal: ",e),Deno.exit(1)),t.push(token(e,TokenType.Number))}else if(isalpha(r[0])){let e="";for(;r.length>0&&isalpha(r[0]);)e+=r.shift();const n=BINARY_OPERATORS[e],a=KEYWORDS[e];n?t.push(token(e,n)):a?t.push(token(e,a)):t.push(token(e,TokenType.Identifier))}else isskippable(r[0])?r.shift():(console.error("Unreconized character found in source: ",r[0].charCodeAt(0),r[0]),Deno.exit(1));return t.push(token("EndOfFile",TokenType.EOF)),t}var Parser;function MK_NULL(){return{type:"null",value:null}}function MK_NUMBER(e){return{type:"number",value:e}}function MK_BOOL(e=!0){return{type:"boolean",value:e}}function MK_STRING(e){return{type:"string",value:e}}function MK_LIST(e){return{type:"list",values:e}}function MK_NATIVE_TASK(e){return{type:"native-task",call:e}}Parser=class{tokens=[];not_eof(){return this.tokens[0].type!=TokenType.EOF}at(){return this.tokens[0]}eat(){return this.tokens.shift()}expect(e,t){const r=this.tokens.shift();return r&&r.type==e||(console.error("Parser Error:\n",t,r," - Expecting: ",e),Deno.exit(1)),r}produceAST(e){this.tokens=tokenize(e);const t={kind:"Program",body:[]};for(;this.not_eof();)t.body.push(this.parse_stmt());return t}parse_stmt(){switch(this.at().type){case TokenType.Set:return this.parse_var_declaration();case TokenType.Change:return this.parse_assignment_expr();case TokenType.Task:return this.parse_task_declaration();case TokenType.If:return this.parse_if_stmt();case TokenType.For:return this.parse_for_stmt();case TokenType.From:return this.parse_from_stmt();default:return this.parse_expr()}}parse_for_stmt(){this.eat();const e=this.expect(TokenType.Identifier,"Unexpected token found while parsing for loop. Expected identifier.");if(this.at().type==TokenType.From){this.expect(TokenType.From,"Unexpected token found while parsing for loop. Expected 'from' keyword.");const t=this.parse_additive_expr();this.expect(TokenType.To,"Unexpected token found while parsing for loop. Expected 'to' keyword.");const r=this.parse_additive_expr();let n,a={kind:"NumericLiteral",value:1};return this.at().type==TokenType.By&&(this.eat(),a=this.parse_additive_expr()),n=this.at().type==TokenType.OpenBrace?this.parse_block():[this.parse_stmt()],{kind:"ForFromStmt",identifier:{kind:"Identifier",symbol:e.value},from:t,to:r,body:n,by:a}}if(this.at().type==TokenType.In){this.expect(TokenType.In,"Unexpected token found while parsing for loop. Expected 'in' keyword.");const t=this.parse_range_expr();let r;return r=this.at().type==TokenType.OpenBrace?this.parse_block():[this.parse_stmt()],{kind:"ForInStmt",identifier:{kind:"Identifier",symbol:e.value},iterable:t,body:r}}throw new Error("Unexpected token found while parsing for loop. Expected 'from' or 'in' keyword.")}parse_from_stmt(){this.eat();const e=this.parse_additive_expr();this.expect(TokenType.To,"Unexpected token found while parsing from loop. Expected 'to' keyword.");const t=this.parse_additive_expr();let r,n={kind:"NumericLiteral",value:1};return this.at().type==TokenType.By&&(this.eat(),n=this.parse_additive_expr()),r=this.at().type==TokenType.OpenBrace?this.parse_block():[this.parse_stmt()],{kind:"FromStmt",from:e,to:t,body:r,by:n}}parse_if_stmt(){this.eat();const e=this.parse_expr();let t;return this.at().type==TokenType.Then&&this.eat(),t=this.at().type==TokenType.OpenBrace?this.parse_block():[this.parse_stmt()],this.at().type==TokenType.Else?(this.eat(),this.at().type==TokenType.If?{kind:"IfStmt",condition:e,thenBranch:t,elseBranch:[this.parse_if_stmt()]}:this.at().type==TokenType.OpenBrace?{kind:"IfStmt",condition:e,thenBranch:t,elseBranch:this.parse_block()}:{kind:"IfStmt",condition:e,thenBranch:t,elseBranch:[this.parse_stmt()]}):{kind:"IfStmt",condition:e,thenBranch:t,elseBranch:[]}}parse_block(){this.expect(TokenType.OpenBrace,"Unexpected token found while parsing block. Expected opening brace.");const e=[];for(;this.at().type!=TokenType.EOF&&this.at().type!=TokenType.CloseBrace;)e.push(this.parse_stmt());return this.expect(TokenType.CloseBrace,"Unexpected token found while parsing block. Expected closing brace."),e}parse_task_declaration(){this.eat();return{kind:"TaskDeclaration",name:this.expect(TokenType.Identifier,"Unexpected token found while parsing task declaration. Expected function name.").value,params:this.parse_args().map((e=>("Identifier"!=e.kind&&(console.error("Unexpected token found while parsing function declaration. Expected identifier in parameters."),Deno.exit(1)),e.symbol))),body:this.parse_block()}}parse_var_declaration(){this.eat();const e=[];for(t.call(this);this.at().type==TokenType.Comma;)this.eat(),t.call(this);return{kind:"VarDeclaration",variables:e};function t(){const t=this.expect(TokenType.Identifier,"Expected identifier name following 'comma' in variable declaration.");let r;const n=this.at().type==TokenType.Always;if(n&&this.eat(),this.at().type!=TokenType.To&&this.at().type!=TokenType.Equals)throw new Error("Unexpected token found following identifier name. Expected to or = operator.");this.eat(),r=this.parse_stmt(),n&&!r&&(console.error("Expected expression or value following 'always'."),Deno.exit(1)),e.push({identifier:{kind:"Identifier",symbol:t.value},constant:n,value:r})}}parse_expr(){return this.parse_assignment_expr()}parse_assignment_expr(){this.at().type==TokenType.Change&&this.eat();const e=this.parse_list_call_expr();if(this.at().type==TokenType.To||this.at().type==TokenType.Equals){this.eat();return{kind:"AssignmentExpr",assignee:e,value:this.parse_stmt()}}return e}parse_list_expr(){if(this.at().type==TokenType.OpenBracket){this.eat();const e=this.parse_list_values();return this.expect(TokenType.CloseBracket,"Unexpected token found while parsing list. Expected closing bracket."),{kind:"ListExpr",values:e}}return this.parse_logical_expr()}parse_list_values(){const e=[];for(;this.at().type!=TokenType.CloseBracket;)e.push(this.parse_stmt()),this.at().type==TokenType.Comma&&this.eat();return e}parse_logical_expr(){let e=this.parse_conditional_expr();for(;"and"==this.at().value||"or"==this.at().value;){const t=this.eat().value;e={kind:"LogicalExpr",left:e,right:this.parse_logical_expr(),operator:t}}return e}parse_conditional_expr(){let e=this.parse_additive_expr();if(this.at().type==TokenType.RelationalOperator){const t=this.eat().value;let r=this.parse_additive_expr();for(e={kind:"ConditionalExpr",left:e,right:r,operator:t};this.at().type==TokenType.RelationalOperator;){const t=this.eat().value;let n=this.parse_additive_expr();const a=n;n={kind:"ConditionalExpr",left:r,right:n,operator:t},e={kind:"LogicalExpr",left:e,right:n,operator:"and"},r=a}}return e}parse_additive_expr(){let e=this.parse_multiplicitave_expr();for(;"plus"==this.at().value||"minus"==this.at().value||"+"==this.at().value||"-"==this.at().value;){const t=this.eat().value;e={kind:"BinaryExpr",left:e,right:this.parse_expr(),operator:t}}return e}parse_multiplicitave_expr(){let e=this.parse_call_member_expr();for(;"divide"==this.at().value||"times"==this.at().value||"modulo"==this.at().value||"/"==this.at().value||"*"==this.at().value||"%"==this.at().value;){const t=this.eat().value;e={kind:"BinaryExpr",left:e,right:this.parse_call_member_expr(),operator:t}}return e}parse_call_member_expr(){const e=this.parse_range_expr();return this.at().type==TokenType.OpenParen?this.parse_call_expr(e):e}parse_list_call_expr(){let e=this.parse_list_expr();return this.at().type==TokenType.OpenBracket&&(e=this.parse_list_index_expr(e)),e}parse_list_index_expr(e){this.expect(TokenType.OpenBracket,"Unexpected token found while parsing list index. Expected opening bracket.");const t=this.parse_expr();return this.expect(TokenType.CloseBracket,"Unexpected token found while parsing list index. Expected closing bracket."),{kind:"ListCallExpr",caller:e,index:t}}parse_call_expr(e){let t={kind:"CallExpr",caller:e,args:this.parse_args()};return this.at().type==TokenType.OpenParen&&(t=this.parse_call_expr(t)),t}parse_args(){this.expect(TokenType.OpenParen,"Unexpected token found while parsing arguments. Expected opening parenthesis.");const e=this.at().type==TokenType.CloseParen?[]:this.parse_args_list();return this.expect(TokenType.CloseParen,"Unexpected token found while parsing arguments. Expected closing parenthesis."),e}parse_args_list(){const e=[this.parse_assignment_expr()];for(;this.at().type==TokenType.Comma;)this.eat(),e.push(this.parse_assignment_expr());return e}parse_range_expr(){const e=this.parse_unary_expr();if(this.at().type==TokenType.DotDot){this.eat();return{kind:"RangeExpr",from:e,to:this.parse_unary_expr()}}return e}parse_unary_expr(){if("plus"==this.at().value||"minus"==this.at().value||"+"==this.at().value||"-"==this.at().value){const e=this.eat().value;return{kind:"UnaryExpr",value:this.parse_unary_expr(),operator:e}}return this.parse_primary_expr()}parse_primary_expr(){switch(this.at().type){case TokenType.Identifier:return{kind:"Identifier",symbol:this.eat().value};case TokenType.Number:return{kind:"NumericLiteral",value:parseFloat(this.eat().value)};case TokenType.String:return{kind:"StringLiteral",value:this.eat().value};case TokenType.OpenParen:{this.eat();const e=this.parse_expr();return this.expect(TokenType.CloseParen,"Unexpected token found inside parenthesised expression. Expected closing parenthesis."),e}default:console.error("Unexpected token found during parsing!",this.at()),Deno.exit(1)}}};const print=(e,t,r)=>{const n=e=>{if("null"==e.type)return"null";if("boolean"==e.type)return e.value?"true":"false";if("number"==e.type)return e.value.toString();if("string"==e.type)return e.value;if("list"==e.type){return"["+e.values.map((e=>n(e))).join(", ")+"]"}if(Array.isArray(e)){return"["+e.map((e=>n(e))).join(", ")+"]"}return"unknown argument type"},a=e.map((e=>n(e))).join(" ");return console.log(a),MK_STRING(a)},ask=(e,t,r)=>{const n=e[0];if("string"!=n.type)throw new Error("Cannot ask for a non-string prompt.");return MK_STRING(prompt(n.value)||"")},NativeTasks={print:print,ask:ask};var Environment,IO;function eval_numeric_binary_expr(e,t,r){let n;if("plus"==r||"+"==r)n=e.value+t.value;else if("minus"==r||"-"==r)n=e.value-t.value;else if("times"==r||"*"==r)n=e.value*t.value;else if("divide"==r||"/"==r){if(0==t.value)throw new Error("Division by zero!");n=e.value/t.value}else n=e.value%t.value;return{value:n,type:"number"}}function eval_string_binary_expr(e,t,r){let n;if("plus"!=r&&"+"!=r)throw new Error(`Invalid binary operator: ${r}`);return n=e.value+t.value,MK_STRING(n)}function eval_binary_expr(e,t,r){const n=evaluate(e.left,t,r),a=evaluate(e.right,t,r);if("number"==n.type&&"number"==a.type)return eval_numeric_binary_expr(n,a,e.operator);if("string"==n.type&&"string"==a.type)return eval_string_binary_expr(n,a,e.operator);if("list"==n.type&&"list"==a.type){const t=n,r=a;if("plus"==e.operator||"+"==e.operator)return MK_LIST(t.values.concat(r.values))}else if("list"==n.type&&"number"==a.type){const t=n,r=a;if("times"==e.operator||"*"==e.operator){const e=[];for(let n=0;n<r.value;n++)e.push(...t.values);return MK_LIST(e)}}else if("number"==n.type&&"list"==a.type){const t=n,r=a;if("times"==e.operator||"*"==e.operator){const e=[];for(let n=0;n<t.value;n++)e.push(...r.values);return MK_LIST(e)}}else if("string"==n.type&&"number"==a.type){const t=n,r=a;if("times"==e.operator||"*"==e.operator){let e="";for(let n=0;n<r.value;n++)e+=t.value;return MK_STRING(e)}}else if("number"==n.type&&"string"==a.type){const t=n,r=a;if("times"==e.operator||"*"==e.operator){let e="";for(let n=0;n<t.value;n++)e+=r.value;return MK_STRING(e)}}return MK_NULL()}function eval_unary_expr(e,t,r){if("-"==e.operator||"minus"==e.operator){return{value:-1*evaluate(e.value,t,r).value,type:"number"}}if("+"==e.operator||"plus"==e.operator){return{value:evaluate(e.value,t,r).value,type:"number"}}return MK_NULL()}function eval_identifier(e,t){return t.lookupVar(e.symbol)}function eval_program(e,t,r){let n=MK_NULL();for(const a of e.body)n=evaluate(a,t,r);return n}function eval_var_declaration(e,t,r){let n=MK_NULL();for(const a of e.variables)n=t.declareVar(a.identifier.symbol,evaluate(a.value,t,r),a.constant);return n}function eval_task_declaration(e,t){const r={type:"task",name:e.name,params:e.params,declarationEnv:t,body:e.body};return t.declareVar(e.name,r,!0)}function evaluate(e,t,r){switch(e.kind){case"NumericLiteral":return MK_NUMBER(e.value);case"NullLiteral":return MK_NULL();case"StringLiteral":return MK_STRING(e.value);case"Identifier":return eval_identifier(e,t);case"ListExpr":return eval_list_expr(e,t,r);case"CallExpr":return eval_call_expr(e,t,r);case"ListCallExpr":return eval_list_call_expression(e,t,r);case"AssignmentExpr":return eval_assignment_expr(e,t,r);case"LogicalExpr":return eval_logical_expr(e,t,r);case"ConditionalExpr":return eval_conditional_expr(e,t,r);case"BinaryExpr":return eval_binary_expr(e,t,r);case"RangeExpr":return eval_range_expr(e,t,r);case"UnaryExpr":return eval_unary_expr(e,t,r);case"Program":return eval_program(e,t,r);case"VarDeclaration":return eval_var_declaration(e,t,r);case"TaskDeclaration":return eval_task_declaration(e,t);case"IfStmt":return eval_if_statement(e,t,r);case"ForFromStmt":return eval_for_from_statement(e,t,r);case"ForInStmt":return eval_for_in_statement(e,t,r);case"FromStmt":return eval_from_statement(e,t,r);default:console.error("This AST Node has not yet been setup for interpretation.",e),Deno.exit(0)}}function eval_list_expr(e,t,r){return MK_LIST(e.values.map((e=>evaluate(e,t,r))))}function eval_list_call_expression(e,t,r){const n=evaluate(e.index,t,r);if("number"==n.type){const a=evaluate(e.caller,t,r);let s=MK_NULL();const o=n;if("list"==a.type){const e=a;if(o.value<0){if(Math.abs(o.value)>e.values.length)throw new Error("Index out of bounds");s=e.values[e.values.length+o.value]}else{if(o.value>=e.values.length)throw new Error("Index out of bounds");s=e.values[o.value]}}else{if("string"!=a.type)throw new Error(`Invalid caller type: ${a.type}`);{const e=a;if(o.value<0){if(Math.abs(o.value)>e.value.length)throw new Error("Index out of bounds");s=MK_STRING(e.value[e.value.length+o.value])}else{if(o.value>=e.value.length)throw new Error("Index out of bounds");s=MK_STRING(e.value[o.value])}}}return s}if("list"==n.type){const a=evaluate(e.caller,t,r),s=n.values.map((e=>{if("number"!=e.type)throw new Error("Invalid index expression, expected number");return e.value})),o=[];if("string"==a.type){const e=a;for(const t of s)if(t<0){if(Math.abs(t)>e.value.length)throw new Error("Index out of bounds");o.push(MK_STRING(e.value[e.value.length+t]))}else{if(t>=e.value.length)throw new Error("Index out of bounds");o.push(MK_STRING(e.value[t]))}return MK_STRING(o.map((e=>e.value)).join(""))}if("list"==a.type){const e=a;for(const t of s)if(t<0){if(Math.abs(t)>e.values.length)throw new Error("Index out of bounds");o.push(e.values[e.values.length+t])}else{if(t>=e.values.length)throw new Error("Index out of bounds");o.push(e.values[t])}return MK_LIST(o)}throw new Error(`Invalid caller type: ${a.type}`)}throw new Error("Invalid index expression, expected number")}function eval_assignment_expr(e,t,r){if("Identifier"==e.assignee.kind){const n=e.assignee.symbol;return t.assignVar(n,evaluate(e.value,t,r))}if("ListCallExpr"==e.assignee.kind){const n=e.assignee,a=n.caller.symbol,s=evaluate(n.index,t,r),o=evaluate(n.caller,t,r);if("number"!=s.type)throw new Error("Invalid index expression, expected number");if(s.value<0){if(Math.abs(s.value)>o.values.length)throw new Error("Index out of bounds");o.values[o.values.length+s.value]=evaluate(e.value,t,r)}else{if(s.value>=o.values.length)throw new Error("Index out of bounds");o.values[s.value]=evaluate(e.value,t,r)}return a?t.assignVar(a,o):o}throw new Error(`Invalid LHS of expr: ${JSON.stringify(e.assignee)}`)}function eval_logical_expr(e,t,r){const n=evaluate(e.left,t,r);if("boolean"==n.type){let a;if("and"==e.operator){const s=evaluate(e.right,t,r);a=n.value&&s.value}else{if("or"!=e.operator)throw new Error(`Invalid logical operator: ${e.operator}`);if(n.value)return MK_BOOL(!0);a=evaluate(e.right,t,r).value}return MK_BOOL(a)}return MK_NULL()}function eval_conditional_expr(e,t,r){const n=evaluate(e.left,t,r),a=evaluate(e.right,t,r);if("number"==n.type&&"number"==a.type){let t;return t="=="==e.operator?n.value==a.value:"!="==e.operator?n.value!=a.value:"<"==e.operator?n.value<a.value:">"==e.operator?n.value>a.value:"<="==e.operator?n.value<=a.value:n.value>=a.value,MK_BOOL(t)}return MK_NULL()}function eval_call_expr(e,t,r){const n=e.args.map((e=>evaluate(e,t,r))),a=evaluate(e.caller,t,r);if("task"==a.type){const e=a,t=new Environment(e.declarationEnv);if(n.length!=e.params.length)throw new Error(`Invalid number of arguments to the task ${e.name}; Expected ${e.params.length}, got ${n.length}`);for(let r=0;r<e.params.length;r++)t.declareVar(e.params[r],n[r],!1);let s=MK_NULL();for(const n of e.body)s=evaluate(n,t,r);return s}if("native-task"==a.type){return a.call(n,t,r)}throw new Error(`Invalid call expression: ${JSON.stringify(e)}`)}function eval_range_expr(e,t,r){const n=evaluate(e.from,t,r),a=evaluate(e.to,t,r);if("number"!=n.type||"number"!=a.type)throw new Error("Invalid range expression, expected numbers");const s=[];if(n.value<a.value)for(let e=n.value;e<=a.value;e++)s.push(e);else for(let e=n.value;e>=a.value;e--)s.push(e);return MK_LIST(s.map((e=>({type:"number",value:e}))))}function eval_if_statement(e,t,r){const n=evaluate(e.condition,t,r);"boolean"!=n.type&&(console.error("Invalid condition for if statement"),Deno.exit(1));let a=MK_NULL();const s=new Environment(t);if(n.value)for(const t of e.thenBranch)a=evaluate(t,s,r);else for(const t of e.elseBranch)a=evaluate(t,s,r);return a}function eval_for_from_statement(e,t,r){const n=evaluate(e.from,t,r),a=evaluate(e.to,t,r),s=evaluate(e.by,t,r);"number"==n.type&&"number"==a.type||(console.error("Invalid from statement, expected numbers"),Deno.exit(1));const o=[],i=new Environment(t);if(i.declareVar(e.identifier.symbol,MK_NULL(),!1),n.value<a.value)for(let t=n.value;t<=a.value;t+=s.value){i.assignVar(e.identifier.symbol,MK_NUMBER(t));for(const t of e.body)o.push(evaluate(t,i,r))}else for(let t=n.value;t>=a.value;t-=s.value){i.assignVar(e.identifier.symbol,MK_NUMBER(t));for(const t of e.body)o.push(evaluate(t,i,r))}return{type:"list",values:o}}function eval_for_in_statement(e,t,r){const n=evaluate(e.iterable,t,r);"list"!=n.type&&(console.error("Invalid for-in statement, expected string"),Deno.exit(1));const a=[],s=new Environment(t);s.declareVar(e.identifier.symbol,MK_NULL(),!1);for(let t=0;t<n.values.length;t++){s.assignVar(e.identifier.symbol,n.values[t]);for(const t of e.body)a.push(evaluate(t,s,r))}return{type:"list",values:a}}function eval_from_statement(e,t,r){const n=evaluate(e.from,t,r),a=evaluate(e.to,t,r),s=evaluate(e.by,t,r);"number"==n.type&&"number"==a.type&&"number"==s.type||(console.error("Invalid from statement, expected numbers"),Deno.exit(1));const o=[],i=new Environment(t);if(n.value<a.value)for(let t=n.value;t<=a.value;t+=s.value)for(const t of e.body)o.push(evaluate(t,i,r));else for(let t=n.value;t>=a.value;t-=s.value)for(const t of e.body)o.push(evaluate(t,i,r));return{type:"list",values:o}}Environment=class{parent;variables;constants;constructor(e){this.parent=e,this.variables=new Map,this.constants=new Set}createGlobalEnv(){return this.declareVar("null",MK_NULL(),!0),this.declareVar("true",MK_BOOL(!0),!0),this.declareVar("false",MK_BOOL(!1),!0),this.declareVar("print",MK_NATIVE_TASK(NativeTasks.print),!0),this.declareVar("ask",MK_NATIVE_TASK(NativeTasks.ask),!0),this}declareVar(e,t,r){if(this.variables.has(e))throw`Cannot declare variable ${e}. As it already is defined.`;return this.variables.set(e,t),r&&this.constants.add(e),t}assignVar(e,t){const r=this.resolve(e);if(r.constants.has(e))throw`Cannot assign to constant variable ${e}.`;return r.variables.set(e,t),t}lookupVar(e){return this.resolve(e).variables.get(e)}resolve(e){if(this.variables.has(e))return this;if(null==this.parent)throw`Cannot resolve '${e}' as it does not exist.`;return this.parent.resolve(e)}},IO=class{inputStream=[];outputStream=[];constructor(e){e&&this.feedInput(e)}read(){return this.inputStream.shift()||MK_NULL()}write(e){this.outputStream.push(JSON.stringify(e))}getOutput(){return this.outputStream.join(" ")}clearOutput(){this.outputStream=[]}clearInput(){this.inputStream=[]}feedInput(e){this.inputStream=e.split(" ").map((e=>{const t="true"==e||"false"==e;return!isNaN(Number(e))?MK_NUMBER(Number(e)):t?MK_BOOL("true"==e):MK_NULL()}))}};const parser=new Parser,env=new Environment,io=new IO;env.createGlobalEnv();const arg0=Deno.args[0];function repl(){for(console.log("\nRepl v0.1 - Leaf\n");;){const e=prompt("> ");e&&!e.includes("exit")||Deno.exit(0);const t=parser.produceAST(e);let r;try{r=evaluate(t,env,io),console.log(r)}catch(e){console.error(e);continue}}}function run(e){e.endsWith(".leaf")||(console.error("Invalid file type, expected .leaf"),Deno.exit(1));const t=Deno.readTextFileSync(e),r=evaluate(parser.produceAST(t),env,io);console.log(r)}"--repl"===arg0?repl():arg0?run(arg0):console.log("No file or option specified");